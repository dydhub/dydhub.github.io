<!DOCTYPE html>
<!--[if lte IE 8 ]>
<html class="ie" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US" lang="en-US">
<![endif]-->
<!--[if (gte IE 9)|!(IE)]><!-->
<!--
***************  *      *     *
      8          *    *       *
      8          *  *         *
      8          **           *
      8          *  *         *
      8          *    *       *
      8          *      *     *
      8          *        *   ***********    -----Theme By Kieran(http://go.kieran.top)
-->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh-CN" lang="zh-CN">
<!--<![endif]-->

<head>
  <title>DydHub</title>
  <!-- Meta data -->
    <meta http-equiv="Content-Type" content="text/html" charset="UTF-8" >
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="generator" content="DydHub">
    <meta name="author" content="dyd">
    <meta name="description" content="Eight hours away" />
    <meta name="keywords" content="" />

    <!-- Favicon, (keep icon in root folder) -->
    <link rel="Shortcut Icon" href="/img/favicon.ico" type="image/ico">

    <link rel="alternate" href="/atom.xml" title="DydHub" type="application/atom+xml">
    <link rel="stylesheet" href="/css/all.css" media="screen" type="text/css">
    
    <link rel="stylesheet" href="/highlightjs/vs.css" type="text/css">
    

    <!--[if IE 8]>
    <link rel="stylesheet" type="text/css" href="/css/ie8.css" />
    <![endif]-->

    <!-- jQuery | Load our jQuery, with an alternative source fallback to a local version if request is unavailable -->
    <script src="/js/jquery-1.11.1.min.js"></script>
    <script>window.jQuery || document.write('<script src="js/jquery-1.11.1.min.js"><\/script>')</script>

    <!-- Load these in the <head> for quicker IE8+ load times -->
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
    <script src="/js/html5shiv.min.js"></script>
    <script src="/js/respond.min.js"></script>
    <![endif]-->

  
  
  

  <style>.col-md-8.col-md-offset-2.opening-statement img{display:none;}</style>
</head>

<!--
<body class="post-template">
-->
<body id="index" class="lightnav animsition">

      <!-- ============================ Off-canvas navigation =========================== -->

    <div class="sb-slidebar sb-right sb-style-overlay sb-momentum-scrolling">
        <div class="sb-close" aria-label="Close Menu" aria-hidden="true">
            <img src="/img/close.png" alt="Close"/>
        </div>
        <!-- Lists in Slidebars -->
        <ul class="sb-menu">
            <li><a href="/" class="animsition-link" title="Home">Home</a></li>
            <li><a href="/archives" class="animsition-link" title="archive">archives</a></li>
            <!-- Dropdown Menu -->
			 
            <li>
                <a class="sb-toggle-submenu">Works<span class="sb-caret"></span></a>
                <ul class="sb-submenu">
                    
                        <li><a href="/" target="_BLANK" class="animsition-link">AAA</a></li>
                    
                        <li><a href="/atom.xml" target="_BLANK" class="animsition-link">BBB</a></li>
                    
                </ul>
            </li>
            
            
            
            <li>
                <a class="sb-toggle-submenu">Links<span class="sb-caret"></span></a>
                <ul class="sb-submenu">
                    
                    <li><a target="_blank" rel="noopener" href="http://go.kieran.top/" class="animsition-link">Kieran</a></li>
                    
                    <li><a target="_blank" rel="noopener" href="http://domain.com/" class="animsition-link">Name</a></li>
                    
                </ul>
            </li>
            
        </ul>
        <!-- Lists in Slidebars -->
        <ul class="sb-menu secondary">
            
            <li><a href="/about.html" class="animsition-link" title="about">About</a></li>
            <li><a href="/atom.xml" class="animsition-link" title="rss">RSS</a></li>
        </ul>
    </div>
    
    <!-- ============================ END Off-canvas navigation =========================== -->

    <!-- ============================ #sb-site Main Page Wrapper =========================== -->

    <div id="sb-site">
        <!-- #sb-site - All page content should be contained within this id, except the off-canvas navigation itself -->

        <!-- ============================ Header & Logo bar =========================== -->

        <div id="navigation" class="navbar navbar-fixed-top">
            <div class="navbar-inner">
                <div class="container">
                    <!-- Nav logo -->
                    <div class="logo">
                        <a href="/" title="Logo" class="animsition-link">
                         <img src="/img/dydzt.jpg" alt="Logo" width="35px;"/> 
                        </a>
                    </div>
                    <!-- // Nav logo -->
                    <!-- Info-bar -->
                    <nav>
                        <ul class="nav">
                            <li><a href="/" class="animsition-link">DydHub</a></li>
                            <li class="nolink"><span>Always </span>Creative.</li>
                            
                            <li><a href="https://github.com/" title="Github" target="_blank"><i class="icon-github"></i></a></li>
                            
                            
                            <li><a href="https://twitter.com/" title="Twitter" target="_blank"><i class="icon-twitter"></i></a></li>
                            
                            
                            <li><a href="https://www.facebook.com/" title="Facebook" target="_blank"><i class="icon-facebook"></i></a></li>
                            
                            
                            <li><a href="https://google.com/" title="Google-Plus" target="_blank"><i class="icon-google-plus"></i></a></li>
                            
                            
                            <li><a href="http://weibo.com/" title="Sina-Weibo" target="_blank"><i class="icon-sina-weibo"></i></a></li>
                            
                            <li class="nolink"><span>Welcome!</span></li>
                        </ul>
                    </nav>
                    <!--// Info-bar -->
                </div>
                <!-- // .container -->
                <div class="learnmore sb-toggle-right">More</div>
                <button type="button" class="navbar-toggle menu-icon sb-toggle-right" title="More">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar before"></span>
                <span class="icon-bar main"></span>
                <span class="icon-bar after"></span>
                </button>
            </div>
            <!-- // .navbar-inner -->
        </div>

        <!-- ============================ Header & Logo bar =========================== -->


      
<section id="intro">
    <div class="container">
        <div class="row col-md-offset-2">
            <div class="col-md-8">
    			<span class="post-meta">
      <time datetime="2020-11-07T03:53:13.981Z" itemprop="datePublished">
          2020-11-07
      </time>
    
</span>
                <h1></h1>
            </div>
        </div>
        <div class="col-md-8 col-md-offset-2">
      		<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">title:Android中进程间通信（IPC）方式总结</span><br></pre></td></tr></table></figure>

<h2 id="Android中进程间通信（IPC）方式总结"><a href="#Android中进程间通信（IPC）方式总结" class="headerlink" title="Android中进程间通信（IPC）方式总结"></a>Android中进程间通信（IPC）方式总结</h2><p>[TOC]</p>
<p><img src="D:\xunlei\65f41806fa9.jpg"></p>
<p><strong>IPC为进程间通信或跨进程通信，是指两个进程进行进程间通信的过程。</strong>在PC和移动设备上一个进程指的是一个程序或者一个应用，所以我们可以将进程间通信简单的理解为：<strong>不同应用之间的通信，</strong>当然这种说法并不严谨。</p>
<p>在Android中，为每一个应用程序都分配了一个独立的虚拟机，或者说每个进程都分配一个独立的虚拟机，不同虚拟机在内存分配上都有不同的地址空间，这就导致在不同的虚拟机互相访问数据需要借助其他手段。<strong>下面分别介绍一下在Android中实现IPC的方式：</strong></p>
<h3 id="使用Bundle的方式"><a href="#使用Bundle的方式" class="headerlink" title="使用Bundle的方式"></a>使用Bundle的方式</h3><p>我们知道在Android中三大组件（Activity，Service，Receiver）都支持在Intent中传递Bundle数据，由于Bundle实现了Parceable接口，所以它可以很方便的在不同的进程之间进行传输。当我们在一个进程中启动另外一个进程的Activity，Service，Receiver时，我们就可以在Bundle中附加我们所需要传输给远程的进程的信息，并且通过Intent发送出去。<strong>这里注意：我们传输的数据必须基本数据类型或者能够被序列化。</strong></p>
<p>1：基本数据类型（int, long, char, boolean, double等） 2：String和CharSequence 3：List：只支持ArrayList，并且里面的元素都能被AIDL支持 4：Map：只支持HashMap，里面的每个元素能被AIDL支持 5：Parcelable：所有实现Parcelable接口的对象``` 下面看一个Demo例子：利用Bundle进行进程间通信</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Intent intent &#x3D; new Intent(MainActivity.this, TwoActivity.class);</span><br><span class="line"></span><br><span class="line">Bundle bundle &#x3D; new Bundle();</span><br><span class="line"></span><br><span class="line">bundle.putString(&quot;data&quot;, &quot;测试数据&quot;);</span><br><span class="line"></span><br><span class="line">intent.putExtras(bundle);</span><br><span class="line"></span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure>

<p><strong>注意：利用Bundle进行进程间通信是很容易的，大家应该注意到，这种方式进行进程间通信只能是单方向的简单数据传输，它使用时有一定的局限性。</strong></p>
<h3 id="使用文件共享的方式"><a href="#使用文件共享的方式" class="headerlink" title="使用文件共享的方式"></a>使用文件共享的方式</h3><p><strong>共享文件也是以后不错的进程间通信的方式，两个进程通过读/写同一个文件来交换数据，</strong>比如<strong>进程A</strong>把数据写入到文件File中，然后<strong>进程B</strong>就可以通过读取这个文件来获取这个数据。通过这种方式，除了可以交换简单的文本信息之外，我们还可以序列化一个对象到文件系统中，另一个进程可以通过反序列化恢复这个对象。</p>
<p>举个例子：</p>
<p>在A进程中创建一个线程进行写数据：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            User user = <span class="keyword">new</span> User(<span class="number">1</span>, <span class="string">&quot;user&quot;</span>, <span class="keyword">false</span>);</span><br><span class="line">            File cachedFile = <span class="keyword">new</span> File(CACHE_FILE_PATH);</span><br><span class="line">            ObjectOutputStream objectOutputStream = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                objectOutputStream = <span class="keyword">new</span> ObjectOutputStream</span><br><span class="line">                               (<span class="keyword">new</span> FileOutputStream(cachedFile));</span><br><span class="line">                objectOutputStream.writeObject(user);</span><br><span class="line">            &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">                objectOutputStream.close();</span><br><span class="line">               &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br></pre></td></tr></table></figure>

<p>在B进程中创建一个线程进行读取数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"> @Override</span><br><span class="line">      public void run() &#123;</span><br><span class="line">           User user &#x3D; null;</span><br><span class="line">           File cachedFile &#x3D; new File(CACHE_FILE_PATH);</span><br><span class="line">           if(cachedFile.exists())&#123;</span><br><span class="line">               ObjectInputStream objectInputStream &#x3D; null;</span><br><span class="line">               try&#123;</span><br><span class="line">                    objectInputStream &#x3D; new ObjectInputStream</span><br><span class="line">                               (new FileInputStream(cachedFile));</span><br><span class="line">                    user &#x3D; objectInputStream.readObject(user);</span><br><span class="line">               &#125;catch(IOException e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">               &#125;finally&#123;</span><br><span class="line">                    objectInputStream.close();</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">               </span><br><span class="line">            try&#123;</span><br><span class="line">               objectOutputStream &#x3D; new ObjectOutputStream</span><br><span class="line">                    (new FileOutputStream(cachedFile));</span><br><span class="line">               objectOutputStream.writeObject(user);</span><br><span class="line">            &#125;catch(IOException e)&#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">            &#125;finally&#123;</span><br><span class="line">               objectOutputStream.close();</span><br><span class="line">            &#125;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>

<p>通过文件共享的这种方式来共享数据对文件的格式是有具体要求的，比如可以是文本文件，也可以是XML文件，只要读写双方约定数据格式即可。这种方式进行进程间通信虽然方便，可是也是有局限性的，比如并发读/写，这会导致比较严重的问题，如读取的数据不完整或者读取的数据不是最新的。因此通过文件共享的方式适合在数据同步要求不高的进程间通信，并且要妥善处理并发读/写问题。</p>
<h3 id="使用Messenger的方式"><a href="#使用Messenger的方式" class="headerlink" title="使用Messenger的方式"></a>使用Messenger的方式</h3><p>我们也可以通过Messenger来进行进程间通信，在Messenger中放入我们需要传递的数据，就可以轻松的实现进程之间数据传递了。Messenger是一种轻量级的IPC方案，它的底层实现是AIDL，关于AIDL我在下面会介绍到。</p>
<p><strong>Messenger的使用方法也是比较简单的，实现一个Messenger有以下几步，分为服务器端和客服端：</strong></p>
<p><strong>服务器进程：</strong>在A进程创建一个Service来处理其他进程的连接请求，同时创建一个Handler并通过它来创建一个Messenger对象，然后在Service的onBind()中返回这个Messenger对象底层的Binder即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class MessengerService extends Service&#123;  </span><br><span class="line">    private Handler MessengerHandler &#x3D; new Handler()&#123;  </span><br><span class="line">        @Override  </span><br><span class="line">        public void handleMessage(Message msg) &#123;  </span><br><span class="line">           &#x2F;&#x2F;消息处理.......            </span><br><span class="line">    &#125;;  </span><br><span class="line">    &#x2F;&#x2F;创建服务端Messenger  </span><br><span class="line">    private final Messenger mMessenger &#x3D; new Messenger(MessengerHandler);  </span><br><span class="line">    @Override  </span><br><span class="line">    public IBinder onBind(Intent intent) &#123;   </span><br><span class="line">        &#x2F;&#x2F;向客户端返回Ibinder对象，客户端利用该对象访问服务端  </span><br><span class="line">        return mMessenger.getBinder();  </span><br><span class="line">    &#125;  </span><br><span class="line">    @Override  </span><br><span class="line">    public void onCreate() &#123;  </span><br><span class="line">        super.onCreate();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>客户端进程：</strong>在进程B中首先绑定远程进程Service，绑定成功后，根据Service返回的IBinder对象创建Messenger对象，并使用此对象发送消息，为了能收到Service端返回的消息，客户端也创建了一个自己的Messenger发送给Service端，Service端就可以通过客户端的Messenger向客户端发送消息了，具体的实现代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class MessengerActivity extends Activity&#123;  </span><br><span class="line">    private ServiceConnection conn &#x3D; new ServiceConnection()&#123;  </span><br><span class="line">        @Override  </span><br><span class="line">        public void onServiceConnected(ComponentName name, IBinder service) &#123;  </span><br><span class="line">            &#x2F;&#x2F;根据得到的IBinder对象创建Messenger  </span><br><span class="line">            mService &#x3D; new Messenger(service);  </span><br><span class="line">            &#x2F;&#x2F;通过得到的mService 可以进行通信</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;;  </span><br><span class="line">      </span><br><span class="line">    &#x2F;&#x2F;为了收到Service的回复，客户端需要创建一个接收消息的Messenger和Handler  </span><br><span class="line">    private Handler MessengerHander &#x3D; new Handler()&#123;  </span><br><span class="line">        @Override  </span><br><span class="line">        public void handleMessage(Message msg) &#123;  </span><br><span class="line">             &#x2F;&#x2F;消息处理</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;;  </span><br><span class="line">    private Messenger mGetMessenger &#x3D; new Messenger(MessengerHander);  </span><br><span class="line"></span><br><span class="line">    @Override  </span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;  </span><br><span class="line">        super.onCreate(savedInstanceState);  </span><br><span class="line">        setContentView(R.layout.activity_messenger);  </span><br><span class="line">        init();  </span><br><span class="line">    &#125;  </span><br><span class="line">    private void init() &#123;  </span><br><span class="line">       intent &#x3D; new Intent(MessengerActivity.this, MessengerService.class);  </span><br><span class="line">       indService(intent, conn, Context.BIND_AUTO_CREATE); </span><br><span class="line">    &#125;  </span><br><span class="line"> </span><br><span class="line">    @Override  </span><br><span class="line">    protected void onDestroy()&#123;  </span><br><span class="line">        unbindService(conn);  </span><br><span class="line">        super.onDestroy();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>下面给出一张Messenger的工作原理图，以便于更好的理解Messenger：</p>
<p>​    ![](C:\Users\a4428\Pictures\Camera Roll\40a332104cc.webp.jpg)</p>
<p>​                                                                                                    Messenger.png</p>
<p>Messenger内部消息处理使用Handler实现的，所以它是以串行的方式处理客服端发送过来的消息的，如果有大量的消息发送给服务器端，服务器端只能一个一个处理，如果并发量大的话用Messenger就不合适了，而且Messenger的主要作用就是为了传递消息，很多时候我们需要跨进程调用服务器端的方法，这种需求Messenger就无法做到了。</p>
<h3 id="使用AIDL的方式"><a href="#使用AIDL的方式" class="headerlink" title="使用AIDL的方式"></a>使用AIDL的方式</h3><p><strong>AIDL（Android Interface Definition Language）是一种IDL语言，用于生成可以在Android设备上两个进程之间进行进程间通信（IPC）的代码。</strong>如果在一个进程中（例如Activity）要调用另一个进程中（例如Service）对象的操作，就可以使用AIDL生成可序列化的参数。</p>
<p>AIDL是IPC的一个轻量级实现，用了对于Java开发者来说很熟悉的语法。Android也提供了一个工具，可以自动创建Stub（类架构，类骨架）。当我们需要在应用间通信时，我们需要按以下几步走：</p>
<p><strong>1：定义一个AIDL接口。</strong></p>
<p><strong>2：为远程服务（Service）实现对应Stub。</strong></p>
<p><strong>3：将服务“暴露”给客户程序使用。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">官方文档中对AIDL有这样一段介绍：</span><br><span class="line"></span><br><span class="line">Using AIDL is necessary only if you allow clients from different applications to access your service for IPC and want to handle multithreading in your service. If you do not need to perform concurrent IPC across different applications, you should create your interface by implementing a Binder or, if you want to perform IPC, but do not need to handle multithreading, implement your interface using a Messenger. Regardless, be sure that you understand Bound Services before implementing an AIDL.</span><br></pre></td></tr></table></figure>

<p><strong>第一句最重要，“只有当你允许来自不同的客户端访问你的服务并且需要处理多线程问题时你才必须使用AIDL”，其他情况下你都可以选择其他方法，如使用Messenger，也能跨进程通信。可见AIDL是处理多线程、多客户端并发访问的。而Messenger是单线程处理。</strong></p>
<p>AIDL很大的好处就是我们直接可以调用服务端进程所暴露出来的方法，下面简单介绍一下使用AIDL的使用方法：</p>
<p><strong>服务端：</strong></p>
<p><strong>（1）：创建aidl接口文件</strong></p>
<p>AIDL使用简单的语法来声明接口，描述其方法以及方法的参数和返回值。这些参数和返回值可以是任何类型的，甚至是其他AIDL生成的接口。重要的是必须导入所有非内置类型，哪怕是这些类型是与接口相同的包中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">package com.example.android;</span><br><span class="line">interface IRemoteService &#123;</span><br><span class="line">    int getPid();</span><br><span class="line">    void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat,</span><br><span class="line">            double aDouble, String aString);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（2）：向客户端暴露接口</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class DDService extends Service &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onCreate() &#123;</span><br><span class="line">        super.onCreate();</span><br><span class="line">        System.out.println(&quot;DDService onCreate........&quot; </span><br><span class="line">               + &quot;Thread: &quot; + Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public IBinder onBind(Intent arg0) &#123;</span><br><span class="line">        System.out.println(&quot;DDService onBind&quot;);</span><br><span class="line">        return mBinder;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    private final IRemoteService.Stub mBinder &#x3D; new IRemoteService.Stub() &#123;</span><br><span class="line">        public int getPid()&#123;</span><br><span class="line">            System.out.println(&quot;Thread: &quot; + Thread.currentThread()</span><br><span class="line">                                                        .getName());</span><br><span class="line">            System.out.println(&quot;DDService getPid &quot;);</span><br><span class="line">            return Process.myPid();</span><br><span class="line">        &#125;</span><br><span class="line">        public void basicTypes(int anInt, long aLong, boolean aBoolean,</span><br><span class="line">            float aFloat, double aDouble, String aString) &#123;</span><br><span class="line">            System.out.println(&quot;Thread: &quot; + Thread.currentThread().getName());</span><br><span class="line">            System.out.println(&quot;basicTypes aDouble: &quot; + aDouble </span><br><span class="line">                               +&quot; anInt: &quot; + anInt+&quot; aBoolean &quot; + aBoolean</span><br><span class="line">                               +&quot; aString &quot; + aString);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样我们的服务器端就完成了，把服务器端运行到手机上，等一会可以看一下打印信息。重点看“线程名”。</p>
<p><strong>客户端：</strong></p>
<p>客户端所做的事情就要简单很多了，首先需要绑定服务器端Service，绑定成功后将服务器端返回的Binder对象转成AIDL接口所属的类型，接着皆可以调用AIDL中的方法了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">public class MainActivity extends Activity &#123;</span><br><span class="line">    private IRemoteService remoteService;</span><br><span class="line">    @Override</span><br><span class="line">    public void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    ServiceConnection conn &#x3D; new ServiceConnection() &#123;</span><br><span class="line">         </span><br><span class="line">        @Override</span><br><span class="line">        public void onServiceDisconnected(ComponentName name) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        @Override</span><br><span class="line">        public void onServiceConnected(ComponentName name, IBinder service) &#123;</span><br><span class="line">            remoteService &#x3D; IRemoteService.Stub.asInterface(service);</span><br><span class="line">            try &#123;</span><br><span class="line">                int pid &#x3D; remoteService.getPid();</span><br><span class="line">                int currentPid &#x3D; Process.myPid();</span><br><span class="line">                System.out.println(&quot;currentPID: &quot; </span><br><span class="line">                                    + currentPid +&quot;  remotePID: &quot; + pid);</span><br><span class="line">                remoteService.basicTypes(12, 1223, true, 12.2f, 12.3, </span><br><span class="line">                                   &quot;我们的爱，我明白&quot;);</span><br><span class="line">            &#125; catch (RemoteException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;bind success! &quot; </span><br><span class="line">                           + remoteService.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">         </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 监听按钮点击</span><br><span class="line">     * @param view</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void buttonClick(View view) &#123;</span><br><span class="line">        System.out.println(&quot;begin bindService&quot;);</span><br><span class="line">        Intent intent &#x3D; new Intent(&quot;duanqing.test.aidl&quot;);</span><br><span class="line">        bindService(intent, conn, Context.BIND_AUTO_CREATE);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    protected void onDestroy() &#123;</span><br><span class="line">        super.onDestroy();</span><br><span class="line">        unbindService(conn);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就实现了AIDL进行进程间通信了，是不是也很简单，不过这个看似简单，<strong>其实底层Android为我们做了很多的事情，核心就是Binder，</strong>感兴趣的读者可以学习一下Binder原理。</p>
<h3 id="使用ContentProvider的方式"><a href="#使用ContentProvider的方式" class="headerlink" title="使用ContentProvider的方式"></a>使用ContentProvider的方式</h3><p>ContentProvider（内容提供者）是Android中的四大组件之一，为了在应用程序之间进行数据交换，Android提供了ContentProvider，ContentProvider是不同应用之间进行数据交换的API，一旦某个应用程序通过ContentProvider暴露了自己的数据操作的接口，那么不管该应用程序是否启动，其他的应用程序都可以通过接口来操作接口内的数据，包括数据的增、删、改、查等操作。ContentProvider分为系统的和自定义的，系统的（例如：联系人，图片等数据）。</p>
<p><strong>开发一个ContentProvider的步骤很简单：</strong></p>
<p>（1）：定义自己的ContentProvider类，该类集成ContentProvider基类；</p>
<p>（2）：在AndroidMainfest.xml中注册这个ContentProvider，类似于Activity注册，注册时要给ContentProvider绑定一个域名；</p>
<p>（3）：当我们注册好这个ContentProvider后，其他应用就可以访问ContentProvider暴露出来的数据了。</p>
<p><strong>ContentProvider只是暴露出来可供其他应用操作的数据，其他应用则需要通过ContentProvider来操作ContentProvider所暴露出来的数据。Content提供了getContentResolver()方法来获取ContentProvider对象，获取之后皆可以对暴露出来的数据进行增、删、改、查操作了。</strong></p>
<p>使用ContentResolver操作数据的步骤也很简单：</p>
<p>（1）调用Activity的getContentResolver()获取ContentResolver对象；</p>
<p>（2）根据调用的ContentResolver的insert()、delete()、update()和query()方法操作数据库即可。</p>
<h3 id="使用广播接收者（Broadcast）的方式"><a href="#使用广播接收者（Broadcast）的方式" class="headerlink" title="使用广播接收者（Broadcast）的方式"></a>使用广播接收者（Broadcast）的方式</h3><p><strong>广播是一种被动跨进程通信方式。当某个程序向系统发送广播时，其他的应用程序只能被动地接收广播数据。</strong>这就像电台进行广播一样，听众只能被动地收听，而不能主动与电台进行沟通。</p>
<p><strong>BroadcastReceiver本质上是一个系统级的监听器，它专门监听各个程序发出的Broadcast，因此它拥有自己的进程，只要存在与之匹配的Intent被广播出来，BroadcastReceivert总会被激发。</strong>我们知道，只要注册了某个广播之后，广播接收者才能收到该广播。广播注册的一个行为是将自己感兴趣的IntentFilter注册到Android系统的AMS（ActivityManagerService）中，里面保存了一个IntentFilter列表。广播发送者将IntentFilter的action行为发送到AMS中，然后遍历AMS中的IntentFilter列表，看谁订阅了该广播，然后将消息遍历发送到注册了相应的IntentFilter或者Service中—也就是说：<strong>会调用抽象方法onReceive()方法。其中AMS起到了中间桥梁的作用。</strong></p>
<p>程序启动BroadcastReceiver只需要两步：</p>
<p>（1）：创建需要启动的BroadcastReceivert的intent；</p>
<p>（2）：调用Context的sendBroadcast()或者sendOrderBroadcast()方法来启动指定的BroadcastReceivert。</p>
<p>每当Broadcast事件发生后，系统会创建对应的BroadcastReceiver实例，并自动触发onReceiver()方法，onReceiver()方法执行完后，BroadcastReceiver实例就会被销毁。</p>
<p>注意：onReceiver()方法中尽量不要做耗时操作，如果onReceiver()方法不能再10秒之内完成事件的处理，Android会认为该进程无响应，也就弹出我们熟悉的ANR对话框。如果我们需要在接收到广播消息后进行耗时的操作，我们可以考虑通过Intent启动一个Server来完成操作，不应该启动一个新线程来完成操作，因为BroadcastReceiver生命周期很短，可能新建线程还没有执行完，BroadcastReceivert已经销毁了，而如果BroadcastReceivert结束了，它所在的进程中虽然还有启动的新线程执行任务，可是由于该进程中已经没有任何组件，因此系统会在内存紧张的情况下回收该进程，这就导致BroadcastReceivert启动的子线程不能执行完成。</p>
<h3 id="使用Socket的方式"><a href="#使用Socket的方式" class="headerlink" title="使用Socket的方式"></a>使用Socket的方式</h3><p>Socaket也是实现进程间通信的一种方式，Socaket也称为“套接字”，网络通信中的概念，通过Socket我们可以很方便的进行网络通信，都可以实现网络通信录，那么实现跨进程通信不是也是相同的嘛，但是Socaket主要还是应用在网络通信中。</p>

            <div class="clearfix"></div>
            <hr class="nogutter">
        </div>
        <nav class="m-pagination col-md-8 col-md-offset-2 col-sm-24" role="pagination">
    
    
    <a class="pull-right" href="/2020/11/06/hello-world/">
        Hello World →
    </a>
    
</nav>

        <div class="col-md-8 col-md-offset-2 col-sm-24"><script type="text/javascript">
  /**
   * 搜狐畅言
   */

  /*
  document.write('<div id="SOHUCS" sid="' + window.location.pathname.slice(1) + '" ></div>');

  window.onload = function () {
    (function () {
      var appid = 'cytXXXX';
      var conf = 'prod_xxxxxxxxxxxxxxxxx';
      var width = window.innerWidth || document.documentElement.clientWidth;
      var loadJs = function (d, a, id) {
        var c = document.getElementsByTagName("head")[0] || document.head || document.documentElement;
        var b = document.createElement("script");
        b.setAttribute("type", "text/javascript");
        b.setAttribute("charset", "UTF-8");
        b.setAttribute("src", d);
        if (id) {
          b.setAttribute("id", id);
        }
        if (typeof a === "function") {
          if (window.attachEvent) {
            b.onreadystatechange = function () {
              var e = b.readyState;
              if (e === "loaded" || e === "complete") {
                b.onreadystatechange = null;
                a()
              }
            }
          } else {
            b.onload = a
          }
        }
        c.appendChild(b)
      };

      loadJs("https://changyan.sohu.com/upload/changyan.js", function () {
        window.changyan.api.config({
          appid: appid,
          conf: conf
        })
      });
    })();
  }
  */

</script>
</div>
    </div>
</section>


      
<!-- ============================ Footer =========================== -->

<footer>
    <div class="container">
            <div class="copy">
                <p>
                    &copy; 2014<script>new Date().getFullYear()>2010&&document.write("-"+new Date().getFullYear());</script>, Content By dyd. All Rights Reserved.
                </p>
                <p>Theme By <a target="_blank" rel="noopener" href="//go.kieran.top" style="color: #767D84">Kieran</a></p>
            </div>
            <div class="social">
                <ul>
                    
                    <li><a href="https://github.com/" title="Github" target="_blank"><i class="icon-github"></i></a>&nbsp;</li>
                    
                    
                    <li><a href="https://twitter.com/" title="Twitter" target="_blank"><i class="icon-twitter"></i></a>&nbsp;</li>
                    
                    
                    <li><a href="https://www.facebook.com/" title="Facebook" target="_blank"><i class="icon-facebook"></i></a>&nbsp;</li>
                    
                    
                    <li><a href="https://google.com/" title="Google-Plus" target="_blank"><i class="icon-google-plus"></i></a>&nbsp;</li>
                    
                    
                    <li><a href="http://weibo.com/" title="Sina-Weibo" target="_blank"><i class="icon-sina-weibo"></i></a>&nbsp;</li>
                    
                </ul>
            </div>
            <div class="clearfix"> </div>
        </div>
</footer>

<!-- ============================ END Footer =========================== -->
      <!-- Load our scripts -->
<!-- Resizable 'on-demand' full-height hero -->
<script type="text/javascript">
    var resizeHero = function () {
        var hero = $(".cover,.heightblock"),
            window1 = $(window);
        hero.css({
            "height": window1.height()
        });
    };

    resizeHero();

    $(window).resize(function () {
        resizeHero();
    });
</script>
<script src="/js/plugins.min.js"></script><!-- Bootstrap core and concatenated plugins always load here -->
<script src="/js/scripts.js"></script><!-- Theme scripts -->


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$('#intro').find('img').each(function(){
  var alt = this.alt;

  if (alt){
    $(this).after('<span class="caption" style="display:none">' + alt + '</span>');
  }

  $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox" rel="gallery" />');
});
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>



      
</body>
</html>
